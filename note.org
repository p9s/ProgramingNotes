* Windows system hosts file path
C:\Windows\System32\drivers\etc
* Programing
** C++ compile errors
*** C4996	'ctime': use _CRT_SECURE_NO_WARNINGS.
项目 -> 属性 -> C/C++ -> 预处理器 -> 预处理器定义
添加以下语句：
_CRT_SECURE_NO_WARNINGS
** File & Directory
*** C++
**** 检查目录是否存在
***** stat :: windows & linux 通用
#+begin_src C++
  #include <sys/types.h>
  #include <sys/stat.h>

  std::string file_name = "deadman";
  struct stat info;
  if (stat(file_name.c_str(), &info) != 0) {  // does not exist
      printf("cannot access %s\n", file_name.c_str());
  }        
  else if (info.st_mode & S_IFDIR) {          // directory
      printf("%s is a directory\n", file_name.c_str());
  }        
  else {
      printf("%s is no directory\n", file_name.c_str());
  }  
#+end_src 
***** C++ 17 std::filesystem
#+begin_src C++
#include <filesystem>
    
std::string file_name = "deadman";
if (std::filesystem::exists(file_name)) {
    if (std::filesystem::is_directory(file)) {
        printf("%s is a directory\n", file_name.c_str());
    }
    else if (std::filesystem::is_regular_file(file)) {
        printf("%s is a file\n", file_name.c_str());
    }
    else {
        printf("%s exists\n", file_name.c_str());
    } 
}
else {
    printf("%s does not exist\n", file_name.c_str());
}
#+end_src
***** direct.h  _access
#+begin_src C++
  #include <direct.h>
  #include <string.h>
  #include <io.h>
  
  std::string filePath = "d:\\test";
  if (_access(filePath.c_str(), 0) == -1) {
      _mkdir(filePath.c_str());
  }
#+end_src
**** 创建目录 
***** direct.h _mkdir
#+begin_src C++
  #include <direct.h>
  #include <string.h>
  #include <io.h>

  std::string path = "d:\\test";
  _mkdir(path.c_str());
#+end_src
***** system command
#+begin_src C++
#include <string>
std::string filePath = "d:\\test";
std::string cmdStr = "mkdir -p " + filePath;
system(cmdStr.c_str());
#+end_src
**** 写文件
#+begin_src c++
  #include <stdio.h>

  void writeFile(std::string fileName, std::string data)
  {
    if (fileName.isNull())
      return;
  
    FILE *fh;
    fh = fopen(fileName.c_str(), "w");
    if(fh) {
      fprintf(fh, "%d\n", 1);
    }
    fclose(fh);
  }
#+end_src
**** 文件追加内容
#+begin_src C++
#include <fstream>
std::string fileName = "c:\\1.log";
ofstream fh;
fh.open(fileName);
if (fh.is_open()) {
    fh << "infomation" << std::endl;
    fh.close();
}
#+end_src
** DateTime
*** C++
**** get current datetime with string data type
#+begin_src C++
  #include <ctime.h>
  time_t ltime;
  time(&ltime);
  tm *tmStruct = localtime(&ltime);
  
  char cdt[20] = { 0 };
  sprintf(cdt,
  		"%04d-%02d-%02d %02d:%02d:%02d", 
  		tmStruct->tm_year + 1900, 
  		tmStruct->tm_mon + 1, 
  		tmStruct->tm_mday, 
  		tmStruct->tm_hour, 
  		tmStruct->tm_min, 
  		tmStruct->tm_sec
  );
  
  std::string currentDateTime(cdt);
#+end_src
**** process datetime with chrono
#+begin_src C++

#+end_src
** Array
*** Rust
**** define and initial array
#+begin_src rust
  let variable: [dataType; size] = [value1, value2..., valueN];
  let arr:[i32; 3] = [1, 2, 3];
  let arr:[i32; 3] = [default_value_for_each_element, size];
  let arr:[i32; 3] = [0, 3];
#+end_src
**** access array
#+begin_src rust :comments access by for loop
  let arr = [1,2,3,4];

  for idx in 0..4 {
      println!("index is: {} value is: {}", idx, arr[idx]);
  }
#+end_src

#+begin_src rust  :comments access by iter
let arr = [1, 2, 3, 4];
for val in arr.iter() {
    println!("value is: {}", val);
}
#+end_src
**** editble array
#+begin_src rust
  let mut arr = [1, 2, 3, 4];
  arr[0] = 8;
#+end_src
**** pass to function
***** by value
#+begin_src rust
  let arr = [1, 2];
  update(arr);

  fn update(mut arr:[i32;2]) {
      for i in 0..2 {
          arr[i] = 0;
      }
  }
#+end_src
***** by refrence
#+begin_src rust
  let mut arr = [1, 2];
  update(&mut arr);

  fn update(arr:&mut [i32;2]) {
      for i in 0..2 {
          arr[i] = 0;
      }
  }
#+end_src
** HashMap
*** C++
#+begin_src C++ :comments create a hash map
  #include <unordered_map>
  #include <string>
  #include <time>

  struct Info {
    int processTimes;
    std::string state;
  }
  
  std::unordered_map<std::string, Info> files;

  std::string ts = to_string(time(nullptr));
  Info info;
  info.processTimes = 0;
  info.state = "Init states";

  files.insert(pair<std::string, Info>(ts, info));

  auto iter = files.find("key");
  if (iter != files.end()) {
    std::cout << "state: " << iter->second.state << std::endl;
  }
#+end_src

#+begin_src C++ :comments hashmap empty, find, key and value
hashmap.clear();
auto iter = hashmap.find("some key");  // return an iter

iter->first;   // hashmap's key
iter->second;  // hashmap's value
#+end_src
*** Rust
**** create and access hash map 
#+begin_src rust
  use std::collections::HashMap;

  // insert
  let mut contacts = HashMap::new();
  contacts.insert("Danile", "1234567");
  contacts.insert("Katie", "1234567");

  // access
  match contacts.get(&"Danile") {
      Some(&number) => println!("{}", number),
      _ => println!("Don't have Danile's number."),
  }

  contacts.remove(&"Ashley");


  // access by for loop
  for (k, v) in contacts {
      println!("{}: {}": k, v);
  }

  // insert only when key not exists :: entry
  contacts.entry("zhang shan".to_string()).or_insert("1234567");
#+end_src

#+begin_src rust :comments 统计词频
  use std::collections::HashMap;

  let txt = "hello long long string with hello";

  let mut map = HashMap::new();

  for word in txt.split_withspace() {
      let count = map.entry(word).or_insert(0);
      *count += 1;
  }
  println!("{:?}", map);
#+end_src
** String
*** C
#+begin_src C :comments unicode str
  #include <stdio.h>
  #include <wchar.h>

  int main() {
    char ch = 'A';                 // sizeof 1
    wchar_t wch = 'A';             // sizeof 2
    char str[] = "C语言中文网";      // sizeof 17  ?
    wchar_t wstr[] = L"C语言中文网"; // sizeof 14
    return 0;
  }
#+end_src
#+begin_src C :comments wide character length
  #include <stdio.h>
  #include <wchar.h>
  #include <string.h>

  int main()
  {
    char str[] = "C中文";            // strlen(str) ==   7
    wchar_t wstr[] = L"C中文";       // wstrlen(wstr) == 3
    return 0;
  }
#+end_src
#+begin_src C :comments compatibility(兼容) ascii and unicode
  // defined in windows.h
  #ifdef UNICODE
  typedef wchar_t TCHAR;
  #define TEXT(quote) L##quote
  #else
  typedef char TCHAR;
  #define TEXT(quote) quote
  #endif

  TCHAR str[] = TEXT("A 字符串");
#+end_src
*** C++ 
#+begin_src C++ :comments create and init
  #include <iostream>
  #include <string>

  std::string s = "http://localhost:5000";
  std::string s;
  std::string s(5, 's');  // s == "sssss"

  s.length();
  s.size();

  // to c style string
  s.c_str();
#+end_src
#+begin_src C++ :comments string add, insert, delete, replace
  #include <string>
  #include <iostream>

  std::string s1 = "hello";
  std::string s2 = "world";

  char *s3 = "thired";
  char s4[] = "fourth";

  std::string s5 = s1 + s2;
  std::string s6 = s1 + s3;


  // insert
  s5.insert(5, s3);

  // delete
  s2.erase(3);
  s2.erase(3, 2);

  // substr
  string s7 = s1.substr(2, 2);

  // find
  int idx = s1.find("l");
  int idx = s1.rfind("l");
#+end_src 
#+begin_src C++ :comment  split
  // stringstream and getline
  std::vector<std::string> stringSplit(const std::string &str, char delim)
  {
    std::stringstream ss(str);
    std::string item;

    std::vector<std::string> elems;
    while(std::getlines(ss, item, delim)) {
      if (!item.empty())
        elems.push_back(item);
    }
    return elems;
  }

  // with std::string::find
  std::vector<std::string> stringSplit(const std::string &str, char delim)
  {
    std::vector<std::string> elems;
    std::size_t previous = 0;
    std::size_t current = str.find(delim);

    while(current != std::string::nopos) {
      if (current > previous)
        elems.push_back(str.substr(previous, current - previous));
      previous = current + 1;
      current = str.find(delim, previous);
    }

    if (previous != str.size())
      elems.push_back(str.substr(previous));
  
    return elems;
  }
      
  // with regex
  std::vector<std::string> stringSplit(const std::string &str, char delim)
  {
    std::string s;
    s.append(1, delim);
    std::regex reg(s);

    std::vector<std::string> elems(
      std::sregex_token_iterator(
          str.begin(), str.end(), reg, -1),
          std::sregex_token_iterator()
      );
    return elems;
  }
#+end_src
#+begin_src C++ :comments replace
  // replace once
  std::string line = "this@ is@ a string";
  line = line.replace(line.find("@"), 1, "");y

  line = line.replace(line.begin(), line.begin() + 6, "");

  std::string replaceAll(const std::string src, std::string delim) {
    std::string line(src);
    int lastPos = 0;
    // replace all
    while (true) {
      lastPos = line.find(delim, lastPos);
      if (lastPos > 0 && lastPos < line.size()) {
        line = line.replace(lastPos, delim.size(), "");
        lastPos -= delim.size();  // 因为替换掉了一位, 所以位置往前走一位
      } else {
        break;
      }
    }
    return line;
  }
#+end_src
*** Rust
**** create string in rust
#+begin_src rust
let name = string::from("zhang shan");
let name = "zhang shan".to_string();
let name = name.to_owned();   // make name copy 
#+end_src
**** split
#+begin_src rust
let str = "long long long strings".to_string();
let p: Vec<&str> = str.split(" ").collect();
let p: Vec<&str> = str.split_withspace().collect();

// split by \n
let p: Vec<&str> = str.lines().collect();
#+end_src

#+begin_src rust :colnames split usging regex
  // in cargo.toml add: regex="1"
  use regex::Regex;

  let s: &str = "long long long long str";
  let p: Vec<&str> Regex::new(r"\s").unwrap().split(s).collect();
#+end_src

#+begin_src rust
  // split string on Multiple delimiters

  let s: &str =  "electron:muon;positron neutrino-gluon";
  let p: Vec<&str> = s.split(|c| (c == ':') || (c == ';') || (c == ' ')).collect();

  let p: Vec<&st> = s.split([':', ';', ' '].as_ref()).collect();
#+end_src
** struct
* Win32 Printer Driver
** 环境
- vs 2017
- wdk 10.0.17763.1 及 wdk 扩展 :: 需要与 *sdk* 版本对应
- 支持XP, 安装时勾选 Windows XP 支持
** 测试环境
- vmware
- virtualIKD
* Windows Programing
** Windows data types
- 无符号类型:   U 开头,  如: UINT
- 指针类型:  LP(老式写法) or P 开头, 如: LPDWORD or PDWORD
- 句柄类型: H 开头, 如: HWND, HMENU
- 常见类型列表 
  |---------+----------------+-----------+---------------------------------|
  | typedef | int            | INT;      | /* 整形 */                      |
  | typedef | unsigned int   | UINT;     | /* 无符号整形 */                |
  | typedef | unsigned int   | *PUINT;   | /* 无符号整形指针 */            |
  | typedef | int            | BOOL;     | /* 布尔类型 */                  |
  | typedef | unsigned char  | BYTE;     | /* 字节 */                      |
  | typedef | unsigned short | WORD;     | /* WORD (无符号短整型) */       |
  | typedef | unsigned long  | DWORD;    | /* DOUBLE WORD (无符号长整形)*/ |
  | typedef | float          | FLOAT;    | /* 浮点型 */                    |
  | typedef | FLOAT          | *PFLOAT;  | /* 指向float类型指针 */         |
  | typedef | BOOL near      | *PBOOL;   | /* 指向布尔类型指针 */          |
  | typedef | BOOL far       | *LPBOOL;  |                                 |
  | typedef | BYTE near      | *PBYTE;   | /* 指向字节类型指针 */          |
  | typedef | BYTE far       | *LPBYTE;  |                                 |
  | typedef | int near       | *PINT;    | /* 整形指针 */                  |
  | typedef | int far        | *LPINT;   |                                 |
  | typedef | WORD near      | *PWORD;   | /* 指向WORD类型的指针 */        |
  | typedef | WORD far       | *LPWORD;  |                                 |
  | typedef | long far       | *LPLONG;  | /* 指向长整形的指针 */          |
  | typedef | DWORD near     | *PDWORD;  | /* 指向DWORD类型的指针 */       |
  | typedef | DWORD far      | *LPDWORD; |                                 |
  | typedef | void far       | *LPVOID;  | /* 指向void类型的指针 */        |
  | typedef | CONST void far | *LPCVOID; | /* 指向void类型的常指针 */      |
  |---------+----------------+-----------+---------------------------------|
** 宽字符与Unicode
- Windows 2000 起 底层支持 Unicode, 存取效率比 char 高
- 头文件: wchar.h 
  #+begin_src C
  #include "wchar.h"
  wchar_t ch = 'A';
  wchar_t *str = L"C中文";   // 定义宽字符串, L 必须要加
  #+end_src
** 概念 
- window
- handle
- event and message(async)
  #+begin_src C :comments message struct
    typedef struct tagMSG {
      HWND hwnd;          // 消息所属窗口
      UINT message;       // Windows WM_XXX宏
      WPARAM wParam;      // 指定消息附加消息
      LPARAM lParam;      // 指定消息附加消息
      DWORD time;         // 事件投递到队列中的时间
      POINT pt;           // 当前鼠标位置
    } MSG;
  #+end_src
- 消息传递方法
  - 通过 GetMessage, 从队列中获取消息
  - 向窗口直接发送消息
- 设备环境(DC)
  间接访问硬件设备环境(Device Context, DC)
- BeginPaint and EndPaint
  获取或者释放DC Handle
- GDI ::Graphics Device Interface(GDI32.DLL)
- Pen and Brush

** 

