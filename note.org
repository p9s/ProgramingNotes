* Windows system hosts file path
C:\Windows\System32\drivers\etc
* Programing
** C++ compile errors
*** warning C4995 #pragma deprecated
可以用 #pragma warning(disable: xxxx ) 的语法将其禁止掉
在你的工程的预编译头文件（一般来说，就是stdafx.h）中，在 #pragma once 一行后面加上下列三行：
  - #define _CSTDIO_
  - #define _CSTRING_
  - #define _CWCHAR_
这样，编译器就不会再加载 cstdio / cstring / cwchar 这几个头文件了。
*** C4996	'ctime': use _CRT_SECURE_NO_WARNINGS.
项目 -> 属性 -> C/C++ -> 预处理器 -> 预处理器定义
添加以下语句：
_CRT_SECURE_NO_WARNINGS
** File & Directory
*** C++
**** 检查目录是否存在
***** stat :: windows & linux 通用
#+begin_src C++
  #include <sys/types.h>
  #include <sys/stat.h>

  std::string file_name = "deadman";
  struct stat info;
  if (stat(file_name.c_str(), &info) != 0) {  // does not exist
      printf("cannot access %s\n", file_name.c_str());
  }        
  else if (info.st_mode & S_IFDIR) {          // directory
      printf("%s is a directory\n", file_name.c_str());
  }        
  else {
      printf("%s is no directory\n", file_name.c_str());
  }  
#+end_src 
***** C++ 17 std::filesystem
#+begin_src C++
#include <filesystem>
    
std::string file_name = "deadman";
if (std::filesystem::exists(file_name)) {
    if (std::filesystem::is_directory(file)) {
        printf("%s is a directory\n", file_name.c_str());
    }
    else if (std::filesystem::is_regular_file(file)) {
        printf("%s is a file\n", file_name.c_str());
    }
    else {
        printf("%s exists\n", file_name.c_str());
    } 
}
else {
    printf("%s does not exist\n", file_name.c_str());
}
#+end_src
***** direct.h  _access
#+begin_src C++
  #include <direct.h>
  #include <string.h>
  #include <io.h>
  
  std::string filePath = "d:\\test";
  if (_access(filePath.c_str(), 0) == -1) {
      _mkdir(filePath.c_str());
  }
#+end_src
**** 创建目录 
***** direct.h _mkdir
#+begin_src C++
  #include <direct.h>
  #include <string.h>
  #include <io.h>

  std::string path = "d:\\test";
  _mkdir(path.c_str());
#+end_src
***** system command
#+begin_src C++
#include <string>
std::string filePath = "d:\\test";
std::string cmdStr = "mkdir -p " + filePath;
system(cmdStr.c_str());
#+end_src
**** 写文件
#+begin_src c++
  #include <stdio.h>

  void writeFile(std::string fileName, std::string data)
  {
    if (fileName.isNull())
      return;
  
    FILE *fh;
    fh = fopen(fileName.c_str(), "w");
    if(fh) {
      fprintf(fh, "%d\n", 1);
    }
    fclose(fh);
  }
#+end_src
**** 文件追加内容
#+begin_src C++
#include <fstream>
std::string fileName = "c:\\1.log";
ofstream fh;
fh.open(fileName);
if (fh.is_open()) {
    fh << "infomation" << std::endl;
    fh.close();
}
#+end_src
** DateTime
*** C++
**** get current datetime with string data type
#+begin_src C++
  #include <ctime.h>
  time_t ltime;
  time(&ltime);
  tm *tmStruct = localtime(&ltime);
  
  char cdt[20] = { 0 };
  sprintf(cdt,
  		"%04d-%02d-%02d %02d:%02d:%02d", 
  		tmStruct->tm_year + 1900, 
  		tmStruct->tm_mon + 1, 
  		tmStruct->tm_mday, 
  		tmStruct->tm_hour, 
  		tmStruct->tm_min, 
  		tmStruct->tm_sec
  );
  
  std::string currentDateTime(cdt);
#+end_src
**** process datetime with chrono
#+begin_src C++

#+end_src
** Array
*** Rust
**** array length
#+begin_src rust :comments get array's length
let arr = [1, 2, 3, 5];
println!("{}", arr.len());
#+end_src
**** define and initial array
#+begin_src rust
  let variable: [dataType; size] = [value1, value2..., valueN];
  let arr:[i32; 3] = [1, 2, 3];
  let arr:[i32; 3] = [default_value_for_each_element, size];
  let arr:[i32; 3] = [0, 3];
#+end_src
**** access array
#+begin_src rust :comments access by for loop
  let arr = [1,2,3,4];

  for idx in 0..4 {
      println!("index is: {} value is: {}", idx, arr[idx]);
  }
#+end_src

#+begin_src rust  :comments access by iter
let arr = [1, 2, 3, 4];
for val in arr.iter() {
    println!("value is: {}", val);
}
#+end_src
**** editble array
#+begin_src rust
  let mut arr = [1, 2, 3, 4];
  arr[0] = 8;
#+end_src
**** pass to function
***** by value
#+begin_src rust
  let arr = [1, 2];
  update(arr);

  fn update(mut arr:[i32;2]) {
      for i in 0..2 {
          arr[i] = 0;
      }
  }
#+end_src
***** by refrence
#+begin_src rust
  let mut arr = [1, 2];
  update(&mut arr);

  fn update(arr:&mut [i32;2]) {
      for i in 0..2 {
          arr[i] = 0;
      }
  }
#+end_src
** HashMap
*** C++
#+begin_src C++ :comments create a hash map
  #include <unordered_map>
  #include <string>
  #include <time>

  struct Info {
    int processTimes;
    std::string state;
  }
  
  std::unordered_map<std::string, Info> files;

  std::string ts = to_string(time(nullptr));
  Info info;
  info.processTimes = 0;
  info.state = "Init states";

  files.insert(pair<std::string, Info>(ts, info));

  auto iter = files.find("key");
  if (iter != files.end()) {
    std::cout << "state: " << iter->second.state << std::endl;
  }
#+end_src

#+begin_src C++ :comments hashmap empty, find, key and value
hashmap.clear();
auto iter = hashmap.find("some key");  // return an iter

iter->first;   // hashmap's key
iter->second;  // hashmap's value
#+end_src
*** Rust
**** create and access hash map 
#+begin_src rust
  use std::collections::HashMap;

  // insert
  let mut contacts = HashMap::new();
  contacts.insert("Danile", "1234567");
  contacts.insert("Katie", "1234567");

  // access
  match contacts.get(&"Danile") {
      Some(&number) => println!("{}", number),
      _ => println!("Don't have Danile's number."),
  }

  // delete
  contacts.remove(&"Ashley");


  // access by for loop
  // for (k, v) in &contacts  maybe this one right?
  for (k, v) in contacts {
      println!("{}: {}": k, v);
  }

  // insert only when key not exists :: entry
  contacts.entry("zhang shan".to_string()).or_insert("1234567");
#+end_src

#+begin_src rust :comments 统计词频
  use std::collections::HashMap;

  let txt = "hello long long string with hello";

  let mut map = HashMap::new();

  for word in txt.split_withspace() {
      let count = map.entry(word).or_insert(0);
      *count += 1;
  }
  println!("{:?}", map);
#+end_src
#+begin_src rust :comments 覆盖更新
  use std::collections::HashMap;
  let scores = HashMap.new();
  score.insert("A1", 50);
  socre.insert("A1", 60); // 覆盖更新
  socre.entry("A1").or_insert(60); // 非覆盖更新
#+end_src
** String
*** C
#+begin_src C :comments unicode str
  #include <stdio.h>
  #include <wchar.h>

  int main() {
    char ch = 'A';                 // sizeof 1
    wchar_t wch = 'A';             // sizeof 2
    char str[] = "C语言中文网";      // sizeof 17  ?
    wchar_t wstr[] = L"C语言中文网"; // sizeof 14
    return 0;
  }
#+end_src
#+begin_src C :comments wide character length
  #include <stdio.h>
  #include <wchar.h>
  #include <string.h>

  int main()
  {
    char str[] = "C中文";            // strlen(str) ==   7
    wchar_t wstr[] = L"C中文";       // wstrlen(wstr) == 3
    return 0;
  }
#+end_src
#+begin_src C :comments compatibility(兼容) ascii and unicode
  // defined in windows.h
  #ifdef UNICODE
  typedef wchar_t TCHAR;
  #define TEXT(quote) L##quote
  #else
  typedef char TCHAR;
  #define TEXT(quote) quote
  #endif

  TCHAR str[] = TEXT("A 字符串");
#+end_src
*** C++ 
#+begin_src C++ :comments create and init
  #include <iostream>
  #include <string>

  std::string s = "http://localhost:5000";
  std::string s;
  std::string s(5, 's');  // s == "sssss"

  s.length();
  s.size();

  // to c style string
  s.c_str();
#+end_src
#+begin_src C++ :comments string add, insert, delete, replace
  #include <string>
  #include <iostream>

  std::string s1 = "hello";
  std::string s2 = "world";

  char *s3 = "thired";
  char s4[] = "fourth";

  std::string s5 = s1 + s2;
  std::string s6 = s1 + s3;


  // insert
  s5.insert(5, s3);

  // delete
  s2.erase(3);
  s2.erase(3, 2);

  // substr
  string s7 = s1.substr(2, 2);

  // find
  int idx = s1.find("l");
  int idx = s1.rfind("l");
#+end_src 
#+begin_src C++ :comment  split
  // stringstream and getline
  std::vector<std::string> stringSplit(const std::string &str, char delim)
  {
    std::stringstream ss(str);
    std::string item;

    std::vector<std::string> elems;
    while(std::getlines(ss, item, delim)) {
      if (!item.empty())
        elems.push_back(item);
    }
    return elems;
  }

  // with std::string::find
  std::vector<std::string> stringSplit(const std::string &str, char delim)
  {
    std::vector<std::string> elems;
    std::size_t previous = 0;
    std::size_t current = str.find(delim);

    while(current != std::string::nopos) {
      if (current > previous)
        elems.push_back(str.substr(previous, current - previous));
      previous = current + 1;
      current = str.find(delim, previous);
    }

    if (previous != str.size())
      elems.push_back(str.substr(previous));
  
    return elems;
  }
      
  // with regex
  std::vector<std::string> stringSplit(const std::string &str, char delim)
  {
    std::string s;
    s.append(1, delim);
    std::regex reg(s);

    std::vector<std::string> elems(
      std::sregex_token_iterator(
          str.begin(), str.end(), reg, -1),
          std::sregex_token_iterator()
      );
    return elems;
  }
#+end_src
#+begin_src C++ :comments replace
  // replace once
  std::string line = "this@ is@ a string";
  line = line.replace(line.find("@"), 1, "");y

  line = line.replace(line.begin(), line.begin() + 6, "");

  std::string replaceAll(const std::string src, std::string delim) {
    std::string line(src);
    int lastPos = 0;
    // replace all
    while (true) {
      lastPos = line.find(delim, lastPos);
      if (lastPos > 0 && lastPos < line.size()) {
        line = line.replace(lastPos, delim.size(), "");
        lastPos -= delim.size();  // 因为替换掉了一位, 所以位置往前走一位
      } else {
        break;
      }
    }
    return line;
  }
#+end_src
*** Rust
**** create string in rust
#+begin_src rust
let name = string::from("zhang shan");
let name = "zhang shan".to_string();
let name = name.to_owned();   // make name copy 
#+end_src
**** split
#+begin_src rust
let str = "long long long strings".to_string();
let p: Vec<&str> = str.split(" ").collect();
let p: Vec<&str> = str.split_withspace().collect();

// split by \n
let p: Vec<&str> = str.lines().collect();
#+end_src

#+begin_src rust :colnames split usging regex
  // in cargo.toml add: regex="1"
  use regex::Regex;

  let s: &str = "long long long long str";
  let p: Vec<&str> Regex::new(r"\s").unwrap().split(s).collect();
#+end_src

#+begin_src rust
  // split string on Multiple delimiters

  let s: &str =  "electron:muon;positron neutrino-gluon";
  let p: Vec<&str> = s.split(|c| (c == ':') || (c == ';') || (c == ' ')).collect();

  let p: Vec<&st> = s.split([':', ';', ' '].as_ref()).collect();
#+end_src
** struct
** UUID
*** C
#+begin_src C :comments generate UUID on linux platform
  // yum install libuuid-devel   # centos install uuid lib
  // apt install uuid-dev        # ubuntu platform
  #include <stdio.h>
  #include <uuid/uuid.h>

  // gcc uuid.c -luuid -o uuid
  int main()
  {
    int i, n;
    uuid_t uu[4];

    cahr buf[1024];
    struct timeval tv;

    // 1
    uuid_generate(uu[0]);

    // 2
    uuid_generate_random(uu[1]);

    // 3
    uuid_generate_time(uu[2]);

    // 4
    n = uuid_generate_time_safe(uu[3]);
    printf("n = %d\n", n);

    for (i = 0; i < 4; ++i) {
      uuid_unparse(uu[i], buf);
      printf("uu[%d]\t%s\n", i, buf);
    }

    uuid_time(uu[2], &tv);
    printf("tv s:%1x u:%1x\n", tv.tv_sec, tv.tv_usec);

    return 0;
  }
#+end_src
*** C++ 
#+begin_src C++ :comments generate by boot std lib, can be used on both linux and windows
  #include <boost/uuid/uuid.hpp>
  #include <boost/uuid/uuid_io.hpp>
  #include <boost/uuid/uuid_generators.hpp>
  #include <string>

  std::boost::uuids::uuid rand = std::boost::uuids::random_generator()();
  const std::string uuid_string = std::boost::uuids::to_string(rand);
#+end_src
#+begin_src C++ :commend generate uuid on windows by winAPI
  #include <objbase.h>

  std::string genUUID()
  {
    char buffer[16] = { 0 };  
    GUID guid;  
   
    if ( CoCreateGuid(&guid) ) {  
      fprintf(stderr, "create guid error\n");  
      return std::string();
    }

    std::stringstream str;
    str.setf(std::ios_base::uppercase);
    // str.unsetf(std::ios_base::uppercase);
    str << std::hex << std::setfill('0')
        << std::setw(2) << (int)((guid.Data1 >> 24) & 0xFF)
        << std::setw(2) << (int)((guid.Data1 >> 16) & 0xFF)
        << std::setw(2) << (int)((guid.Data1 >> 8) & 0xFF)
        << std::setw(2) << (int)((guid.Data1) & 0xFF)

        << std::setw(2) << (int)((guid.Data2 >> 8) & 0xFF)
        << std::setw(2) << (int)(guid.Data2 & 0xFF)

        << std::setw(2) << (int)((guid.Data3 >> 8) & 0xFF)
        << std::setw(2) << (int)(guid.Data3 & 0xFF)


        << std::setw(2) << (int)guid.Data4[0]
        << std::setw(2) << (int)guid.Data4[1]
        << std::setw(2) << (int)guid.Data4[2]
        << std::setw(2) << (int)guid.Data4[3]
        << std::setw(2) << (int)guid.Data4[4]
        << std::setw(2) << (int)guid.Data4[5]
        << std::setw(2) << (int)guid.Data4[6]
        << std::setw(2) << (int)guid.Data4[7];

    return str.str();
  }
#+end_src
#+begin_src C++ gen

#+end_src
** Function return value
*** Rust
**** no return defaults to return ()
#+begin_src rust
fn main() {}
// equal to 
fn main -> () {}
#+end_src
**** return multiple value, it's used tuple data type
#+begin_src rust
    fn main() {
      let (p2, p3) = pow_2_3(789);
    }

  fn pow_2_3(n: i32) -> (i32, i32) {
    (n*n, n*n*n)
  }
#+end_src
**** diverging function(发散函数), 不返回, 使用 ! 作为返回类型
#+begin_src rust
  fn main() {
      println!("hello");
      diverging();
      println("world");
  }

  fn diverging() -> ! {
      panic!("this function will never return");
  }
#+end_src
**** Option
#+begin_src rust
  // enum Option<T> {
  //     None,
  //     Some(T),
  // }

  fn find(haystack: &str, needle: char) -> Option<usize> {
      for (offset, c) in haystack.char_indices() {
          if c == needle {
              return Some(offset);
          }
      }
      None
  }
#+end_src
**** Result
#+begin_src rust
  // enum Result<T, E> {
  //     Ok(T),
  //     Err(E),
  // }

  // type Option<T> = Result<T, ()>;

  // version 1 not good
  fn double_number(number_str: &str) -> i32 {
      2 * number_str.parse::<i32>().unwrap()
  }

  fn main() {
      let n: i32 = double_number("10");
      assert_eq!(n, 20);
  }

  // version 2 better
  use std::num::ParseIntError;

  fn double_number(number_str: &str) -> Result<i32, ParseIntError> {
      number_str.parse::<i32>().map(|n| 2 * n )
  }

  fn main() {
      match double_number("10") {
          Ok(n) => assert_eq!(n, 20),
          Err(err) => println!("{:?}", err);
      }
  }
#+end_src
** typedef
*** C++
ref: https://zhuanlan.zhihu.com/p/413574268
#+begin_src C++ :comments 定义别名
char *pa, *pb;
typedef char* pCHAR;
pChar pa, pb;
#+end_src

#+begin_src C++ :comments 定义新数据类型
  struct Teacher
  {
    int age;
  } Tea;                   // Tea 是一个变量

  typedef struct Student
  {
    int age;
  } Stu;                   // Stu 是一个结构体类型 <==> struct Student

  void main()
  {
    Tea.age = 30;      // 为结构体成员赋值
    Stu Zhang;         // 声明结构体类型变量
    Zhang.age = 15;    // 赋值

  }
#+end_src

#+begin_src C++ :comments 定义平台无关的数据类型
  typedef long double REAL;

  //在不支持 long double 的平台二上，改为：
  typedef double REAL;

  //在连 double 都不支持的平台三上，改为：
  typedef float REAL;
#+end_src

#+begin_src C++ :comments 复杂声明定义简单别名
int *(*a[5])(int, char*); // 原型声明

typedef int *(*pFun)(int, char*);
pFun a[5];

// 在原来的声明里逐步用别名替换一部分复杂声明，如此循环，
// 把带变量名的部分留到最后替换，得到的就是原声明的最简化版。
void (*b[10])(void(*)());  // 原始声明
// 先替换右边括号
typedef void (*pFunParam);
// 再替换左边括号
typedef void (*pFun2)(pFunParam)

// 简化后版本
pFun2 b[10]
#+end_src
* Win32 Printer Driver
** 环境
- vs 2017
- wdk 10.0.17763.1 及 wdk 扩展 :: 需要与 *sdk* 版本对应
- 支持XP, 安装时勾选 Windows XP 支持
** 测试环境
- vmware
- virtualIKD
* Windows Programing
** Windows data types
- 无符号类型:   U 开头,  如: UINT
- 指针类型:  LP(老式写法) or P 开头, 如: LPDWORD or PDWORD
- 句柄类型: H 开头, 如: HWND, HMENU
- 常见类型列表 
  |---------+----------------+-----------+---------------------------------|
  | typedef | int            | INT;      | /* 整形 */                      |
  | typedef | unsigned int   | UINT;     | /* 无符号整形 */                |
  | typedef | unsigned int   | *PUINT;   | /* 无符号整形指针 */            |
  | typedef | int            | BOOL;     | /* 布尔类型 */                  |
  | typedef | unsigned char  | BYTE;     | /* 字节 */                      |
  | typedef | unsigned short | WORD;     | /* WORD (无符号短整型) */       |
  | typedef | unsigned long  | DWORD;    | /* DOUBLE WORD (无符号长整形)*/ |
  | typedef | float          | FLOAT;    | /* 浮点型 */                    |
  | typedef | FLOAT          | *PFLOAT;  | /* 指向float类型指针 */         |
  | typedef | BOOL near      | *PBOOL;   | /* 指向布尔类型指针 */          |
  | typedef | BOOL far       | *LPBOOL;  |                                 |
  | typedef | BYTE near      | *PBYTE;   | /* 指向字节类型指针 */          |
  | typedef | BYTE far       | *LPBYTE;  |                                 |
  | typedef | int near       | *PINT;    | /* 整形指针 */                  |
  | typedef | int far        | *LPINT;   |                                 |
  | typedef | WORD near      | *PWORD;   | /* 指向WORD类型的指针 */        |
  | typedef | WORD far       | *LPWORD;  |                                 |
  | typedef | long far       | *LPLONG;  | /* 指向长整形的指针 */          |
  | typedef | DWORD near     | *PDWORD;  | /* 指向DWORD类型的指针 */       |
  | typedef | DWORD far      | *LPDWORD; |                                 |
  | typedef | void far       | *LPVOID;  | /* 指向void类型的指针 */        |
  | typedef | CONST void far | *LPCVOID; | /* 指向void类型的常指针 */      |
  |---------+----------------+-----------+---------------------------------|
** 宽字符与Unicode
- Windows 2000 起 底层支持 Unicode, 存取效率比 char 高
- 头文件: wchar.h 
  #+begin_src C
  #include "wchar.h"
  wchar_t ch = 'A';
  wchar_t *str = L"C中文";   // 定义宽字符串, L 必须要加
  #+end_src
** 概念 
- window
- handle
- event and message(async)
  #+begin_src C :comments message struct
    typedef struct tagMSG {
      HWND hwnd;          // 消息所属窗口
      UINT message;       // Windows WM_XXX宏
      WPARAM wParam;      // 指定消息附加消息
      LPARAM lParam;      // 指定消息附加消息
      DWORD time;         // 事件投递到队列中的时间
      POINT pt;           // 当前鼠标位置
    } MSG;
  #+end_src
- 消息传递方法
  - 通过 GetMessage, 从队列中获取消息
  - 向窗口直接发送消息
- 设备环境(DC)
  间接访问硬件设备环境(Device Context, DC)
- BeginPaint and EndPaint
  获取或者释放DC Handle
- GDI ::Graphics Device Interface(GDI32.DLL)
- Pen and Brush
* Windows 打印机驱动开发
** Windows 打印流程
src: https://blog.csdn.net/zb774095236/article/details/100985450
1. 通知打印池开始一个新任务
2. 打印池调用打印机接口DLL显示打印对话框, 并将打印设置信息回传打印池
3. 应用程序调用GDI进行绘图
4. GDI将应用程序的绘图调用保存在EMF文件中, 记录完后, 发送给打印池
5. GDI返回应用程序完成一次假脱机打印过程, 可以进行其它任务
6. 打印池调用GDI, 把EMF文件的绘图命令按条分解到打印机上下文中
7. GDI通过系统调用, 调用GDI引擎实现绘图操作
8. GDI引擎将GDI绘图命令分解组合, 通过打印机DLL完成各种图形的绘制
9. 打印机图形DLL将绘图解码后的数据发往打印池
10. 打印池把打印机数据发往打印机
** 完成文档打印需实现的基本函数及表面钩子函数
| DDI函数                        | Desc                     | Ecgprint对应的函数 |
|--------------------------------+--------------------------+--------------------|
| DrvStartDoc                    | 开始打印时调用           | OEMStartDoc        |
| DrvEndDoc                      | 结束打印时调用           | OEMEndDoc          |
| DrvStartPage                   | 开始打印一个物理页时调用 | OEMStartPage       |
| DrvSendPage                    | 打印完一个物理页后调用   | OEMSendPage        |
|--------------------------------+--------------------------+--------------------|
| 以下打印每个物理页根据实际调用 |                          |                    |
|--------------------------------+--------------------------+--------------------|
| DrvAlphaBlend                  | 实现位块透明             | 可选函数, 未实现   |
| DrvBitBlt                      | 实现位块数据传输         | OEMBitBlt          |
| DrvCopyBits                    | 复制位图                 | 可选函数, 未实现   |
| DrvFillPath                    | 填充闭合路径             | 同上               |
| DrvGradientFill                | 绘制阴影                 | 同上               |
| DrvLineTo                      | 划线                     | 同上               |
| DrvNextBand                    | 在物理页绘制完一段后调用 | OEMNextBand        |
| DtrvPlgBlt                     | 旋转位块                 | 可选函数, 未实现   |
| DrvStretchBlt                  | 缩放位块                 | OEMStretchBlt      |
| DrvStrokePath                  | 用画笔绘制Path           | OEMStrokePath      |
|--------------------------------+--------------------------+--------------------|
** 打印机驱动构成
- Printer Graphics DLL
- Printer Interface DLL
** Universal Printer Driver
1. 增加一个GPD文件,  Universal Printer Driver 读取这个文件(Mini Driver)
2. Printer Graphics DLL 相关Plugin 称为: Rendering Plug-Ins
3. PrinterInterface DLL 相关Plugin 称为: User Interface Plug-Ins
** 打印机驱动需完成接口
以下函数在Universal Printer Driver中, 分别在 UNIDRVUI.DLL和UNIDRV.DLL分别实现
1. DevQueryPrintEx
2. DrvConvertDevMode
3. DrvUpgradePrinter
** 双向通信
- 双向通信接口, 由后台处理程序API组成
- 双向通信架构, XML标准, 用于与设备交换信息
** 双向通信要求
- 必须实现双向通信接口: 2选1
  - IBideSpl COM 接口
  - ExploreriSpl2 COM 接口
- 以下2选1接口
  - IBideRequest
  - IBidiRequestContainer COM
- 以下一项或者两项必须为: true
  - SendRecvBideData <-- 实现在打印提供程序 DLL 中
  - SendRecvBidiDataFormPort <-- 实现在语言监视服务器DLL或者端口监视服务器DLL中
** 调用流程
1. 生成请求
2. 调用 IBideSpl
   2.1 单个请求调用 SendRecv 方法
   2.2 多个请求调用 MultiSendRecv 方法
3. 服务端处理程序调用 SendRecvBideData or SendRecvBidiDataFormPort
   ppResData 参数指向内存位置包含打印机响应的  BIDI_RESPONSE_CONTAINER 结构地址
** 如何确定打印机是否支持双向通信
打印机信息2上的属性成员:  
PRINTER_ATTRIBUTE_ENABLE_BIBI  0x0800
表示是否支持双向通信
** GPD File Introduction
*** GPD file provide information
- Printer attributes
- Printer commands
- Printer features
- Printer options
- Printer font descriptions
- Conditional statements
- Compressing raster data
- Handling color formats
- Halftoning with Unidrv
- Handling installable features and options
- Describing printer memory configurations
*** GPD File Entries 
**** GPD File Entry Format
- Format
  *EntryName: EntryValue {GPD_FileEntry, GPD_FileEntry, ...}
- Demo
  #+begin_src C++ :comments The sample of GPD file entry
    ,*Feature: Orientation
    {
        ,*Name: "Orientation"
        ,*DefaultOption: Portrait
        ,*Option: Portrait
        {
            ,*Name: "Portrait"
            ,*Command: CmdSelect
            {
                ,*Order: DOC_SETUP.7
                ,*Cmd: "<1B>&l0O"
            }
        }
        ,*Option: LANDSCAPE_CC90
        {
            ,*Name: "Landscape"
            ,*Command: CmdSelect
            {
                ,*Order: DOC_SETUP.7
                ,*Cmd: "<1B>&l1O"
            }
        }
    }
  #+end_src

**** GPD Value Types
***** Symbolic names
**** Line Continuation
**** Marcos
**** Preprocessor Directives
**** Standard Variables
* CEF
** CefClient 
浏览器的回调事件（拖拽、下载、查找、焦点、键盘等）
都在CefClient类中有对应的注册接口
提供所有浏览器事件处理接口
- CefLifeSpanHandler
- CefRenderHandler
- CefRefPtr<CefDisplayHandler> GetDisplayHandler() { return NULL;}
  Browser对象显示状态的事件处理
- CefRefPtr<CefJSDialogHandler> GetJSDialogHandler() {return NULL;}  
  与JS Dialog相关的回调事件
- OnProcessMessageReceived(CefRefPtr<CefBrowser> browser, CefProcessId source_process, CefRefPtr<CefProcessMessage> message) {return false; }
  进程间通信, browser <--> render
- CefApp    :: 负责进程的实例化及退出
  - GetBrowserProcessHandler() :: 创建 browser 进程
  - GetRenderProcessHandler()  :: 创建 render 进程
- 抽象类
  - CefBrowser     :: 表示一个浏览器窗口 
  - CefFrame       :: 浏览器窗口中一块区域
- 独立子进程执行, 需要两个分开的工程和分开的入口函数, 在主程序的CefSEttings settings中增加
  CefString(&settings.browser_subprocess_path)=子进程执行路径
- JS加载与Cef的交互由Render进程处理, CefApp的GetRenderProcessHandler方法必须提供实现.
  v8 规范, 每一段js代码必须显式指定context, 因此在调用js代码的时候, 必须先进入context,
  每个 Frame 都有属于自己的 context, Frame加载都会调用  OnContextCreate 方法
  - Cef 调用JS
    - GetFrame::ExecuteJavaScript() 执行 JS
      - frame-ExecuteJavaScript(const CefString& jsCode, const

